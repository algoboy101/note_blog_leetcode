---
title: "[0036] Valid Sudoku"
tags:
  - leetcode
categories:
  - leetcode
author: 张学志
comments: true
updated: false
permalink:
mathjax: false
top: false
description: ...
date: 2020-01-01 00:00:36
---

## 题目描述

> 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 
> 
> 
> 数字 1-9 在每一行只能出现一次。 
> 数字 1-9 在每一列只能出现一次。 
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 
> 
> 
> 
> 
> 上图是一个部分填充的有效的数独。 
> 
> 数独部分空格内已填入了数字，空白格用 '.' 表示。 
> 
> 示例 1: 
> 
> 输入:
> [
> ["5","3",".",".","7",".",".",".","."],
> ["6",".",".","1","9","5",".",".","."],
> [".","9","8",".",".",".",".","6","."],
> ["8",".",".",".","6",".",".",".","3"],
> ["4",".",".","8",".","3",".",".","1"],
> ["7",".",".",".","2",".",".",".","6"],
> [".","6",".",".",".",".","2","8","."],
> [".",".",".","4","1","9",".",".","5"],
> [".",".",".",".","8",".",".","7","9"]
> ]
> 输出: true
> 
> 
> 示例 2: 
> 
> 输入:
> [
>   ["8","3",".",".","7",".",".",".","."],
>   ["6",".",".","1","9","5",".",".","."],
>   [".","9","8",".",".",".",".","6","."],
>   ["8",".",".",".","6",".",".",".","3"],
>   ["4",".",".","8",".","3",".",".","1"],
>   ["7",".",".",".","2",".",".",".","6"],
>   [".","6",".",".",".",".","2","8","."],
>   [".",".",".","4","1","9",".",".","5"],
>   [".",".",".",".","8",".",".","7","9"]
> ]
> 输出: false
> 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
> 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 
> 
> 说明: 
> 
> 
> 一个有效的数独（部分已被填充）不一定是可解的。 
> 只需要根据以上规则，验证已经填入的数字是否有效即可。 
> 给定数独序列只包含数字 1-9 和字符 '.' 。 
> 给定数独永远是 9x9 形式的。 
> 
> Related Topics 哈希表

## 题目代码

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        
    }
};
```

## 解析

这道题让验证一个方阵是否为数独矩阵，想必数独游戏我们都玩过，就是给一个 9x9 大小的矩阵，可以分为9个 3x3 大小的矩阵，要求是每个小矩阵内必须都是1到9的数字不能有重复，同时大矩阵的横纵列也不能有重复数字，是一种很经典的益智类游戏，经常在飞机上看见有人拿着纸笔在填数，感觉是消磨时光的利器。这道题给了一个残缺的二维数组，让我们判断当前的这个数独数组是否合法，即要满足上述的条件。判断标准是看各行各列是否有重复数字，以及每个小的 3x3 的小方阵里面是否有重复数字，如果都无重复，则当前矩阵是数独矩阵，但不代表待数独矩阵有解，只是单纯的判断当前未填完的矩阵是否是数独矩阵。那么根据数独矩阵的定义，在遍历每个数字的时候，就看看包含当前位置的行和列以及 3x3 小方阵中是否已经出现该数字，这里需要三个 boolean 型矩阵，大小跟原数组相同，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，具体代码如下：

### 方法一

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<vector<bool>> rowFlag(9, vector<bool>(9));
        vector<vector<bool>> colFlag(9, vector<bool>(9));
        vector<vector<bool>> cellFlag(9, vector<bool>(9));
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') continue;
                int c = board[i][j] - '1';
                if (rowFlag[i][c] || colFlag[c][j] || cellFlag[3 * (i / 3) + j / 3][c]) return false;
                rowFlag[i][c] = true;
                colFlag[c][j] = true;
                cellFlag[3 * (i / 3) + j / 3][c] = true;
            }
        }
        return true;
    }
};
```

### 方法二

我们也可以对空间进行些优化，只使用一个 HashSet 来记录已经存在过的状态，将每个状态编码成为一个字符串，能将如此大量信息的状态编码成一个单一的字符串还是需要有些技巧的。对于每个1到9内的数字来说，其在每行每列和每个小区间内都是唯一的，将数字放在一个括号中，每行上的数字就将行号放在括号左边，每列上的数字就将列数放在括号右边，每个小区间内的数字就将在小区间内的行列数分别放在括号的左右两边，这样每个数字的状态都是独一无二的存在，就可以在 HashSet 中愉快地查找是否有重复存在啦，参见代码如下：

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_set<string> st;
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') continue;
                string t = "(" + to_string(board[i][j]) + ")";
                string row = to_string(i) + t, col = t + to_string(j), cell = to_string(i / 3) + t + to_string(j / 3);
                if (st.count(row) || st.count(col) || st.count(cell)) return false;
                st.insert(row);
                st.insert(col);
                st.insert(cell);
            }
        }
        return true;
    }
};
```


Github 同步地址：

https://github.com/grandyang/leetcode/issues/36

类似题目：

Sudoku Solver

